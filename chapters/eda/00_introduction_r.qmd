---
execute:
  freeze: auto
---

# Introduzione a R {#sec-r}

**Prerequisiti**

- Leggere [An Introduction to R](https://intro2r.com/).

**Concetti e competenze chiave**

**Preparazione del Notebook**

```{r}
here::here("code", "_common.R") |> source()

# Load packages
if (!requireNamespace("pacman")) install.packages("pacman")
pacman::p_load(tidyr)
```

## Introduzione

### Perché usare R nella Data Analysis?

R è uno dei linguaggi di programmazione più utilizzati nella data analysis, grazie alla sua flessibilità, potenza e vasta comunità di supporto. È stato progettato specificamente per l’analisi statistica e il data visualization, ed è particolarmente apprezzato in ambito accademico e scientifico.

Negli ultimi anni, la **crisi della replicabilità** ha evidenziato problemi significativi nella scienza: molte analisi non possono essere riprodotte, compromettendo la fiducia nei risultati pubblicati [@nosek2022replicability]. Per affrontare questa sfida, è essenziale adottare strumenti che garantiscano **trasparenza** e **riproducibilità**. R soddisfa queste esigenze grazie a tre caratteristiche fondamentali:

1. **Scripting e documentazione**: Ogni analisi è basata su script che possono essere facilmente salvati, condivisi e rivisti. Questo permette di replicare ogni passaggio dell’analisi.
2. **Flessibilità**: Con R è possibile creare flussi di lavoro personalizzati e adattarli a nuovi dati o problemi.
3. **Integrazione con strumenti di reporting**: Grazie a piattaforme come R Markdown o Quarto, è possibile integrare analisi, codice e risultati in documenti unici e dinamici.

A differenza di software basati su interfacce grafiche (GUI), che rischiano di introdurre errori nascosti nei flussi di lavoro, R favorisce una programmazione esplicita, riducendo l’ambiguità e aumentando la verificabilità delle analisi.

Utilizzare R significa non solo imparare uno strumento tecnico, ma adottare un approccio rigoroso e replicabile alla scienza, rispondendo alle esigenze di una ricerca moderna e affidabile.

## Oggetti in R

In R, tutto è un oggetto: dai numeri o stringhe di testo semplici, fino a strutture più complesse come grafici, riassunti di analisi statistiche o script che eseguono compiti specifici. Creare e assegnare valori agli oggetti è fondamentale per lavorare in R.

### Creare oggetti

Per creare un oggetto, basta assegnargli un nome e un valore usando l’operatore di assegnazione `<-`:

```{r}
my_obj <- 48
```

In questo esempio, abbiamo creato un oggetto chiamato `my_obj` e gli abbiamo assegnato il valore 48. Anche l'operatore `=` può essere usato, ma è considerato una cattiva pratica.

Per visualizzare il valore di un oggetto, basta scriverne il nome:

```{r}
my_obj
```

Gli oggetti creati vengono memorizzati nell'ambiente di lavoro. In RStudio, puoi visualizzarli nella scheda **Environment** e ottenere dettagli come tipo, lunghezza e valore.

È possibile assegnare a un oggetto anche una stringa di testo, racchiudendola tra virgolette:

```{r}
my_obj2 <- "R è fantastico"
my_obj2
```

Se dimentichi le virgolette, R mostrerà un errore.

Per modificare il valore di un oggetto esistente, basta riassegnarlo:

```{r}
my_obj2 <- 1024
```

Ora il tipo di `my_obj2` è cambiato da carattere a numerico. È anche possibile usare oggetti per crearne di nuovi:

```{r}
my_obj3 <- my_obj + my_obj2
my_obj3
```

Se provi a sommare oggetti di tipo diverso, R restituirà un errore:

```
char_obj <- "ciao"
char_obj2 <- "mondo"
char_obj3 <- char_obj + char_obj2
# Error in char_obj + char_obj2 : non-numeric argument to binary operator
```

Quando incontri errori come questo, cerca su Google la spiegazione del messaggio, per esempio: "non-numeric argument to binary operator error + r". Un errore comune è anche:

```
my_obj <- 48
my_obj4 <- my_obj + no_obj
# Error: object 'no_obj' not found
```

R segnala che `no_obj` non è stato definito e, di conseguenza, l’oggetto `my_obj4` non è stato creato.

### Nomi degli oggetti

Dare un nome agli oggetti può sembrare banale, ma è importante scegliere nomi brevi e informativi. Usa un formato coerente, come:

- **Snake case**: `output_summary`
- **Dot case**: `output.summary`
- **Camel case**: `outputSummary`

Evita di iniziare i nomi con numeri (es. `2my_variable`) o caratteri speciali (&, ^, /, ecc.). Inoltre, non usare parole riservate (es. `TRUE`, `NA`) o nomi di funzioni già esistenti (es. `data`).

Esempio da evitare:

```
data <- read.table("mydatafile", header = TRUE) # `data` è già una funzione!
```

## Usare le funzioni in R 

Fino ad ora abbiamo creato oggetti semplici assegnando loro direttamente un valore. Con l'aumento dell'esperienza in R, potresti voler creare oggetti più complessi. Per aiutarti, R offre numerose funzioni già disponibili nella sua installazione di base, e altre possono essere aggiunte installando pacchetti. Una funzione è un insieme di istruzioni che eseguono un compito specifico. Inoltre, è possibile creare funzioni personalizzate.

### La funzione `c()` per creare vettori

La prima funzione utile da imparare è `c()`, che serve a concatenare valori in un *vettore*. Ad esempio:

```R
my_vec <- c(2, 3, 1, 6, 4, 3, 3, 7)
```

Questo codice crea un oggetto chiamato `my_vec` che contiene una sequenza di numeri. Alcuni concetti fondamentali sulle funzioni in R:

1. **Nome e parentesi**: Le funzioni in R sono sempre seguite da parentesi tonde `()`.
2. **Argomenti**: Gli elementi passati alla funzione (tra le parentesi) ne personalizzano il comportamento.

Per vedere il contenuto del vettore:

```R
my_vec
## [1] 2 3 1 6 4 3 3 7
```

### Funzioni per analizzare vettori

Puoi utilizzare altre funzioni per calcolare statistiche sul vettore:

```R
mean(my_vec)    # Media
## [1] 3.625
var(my_vec)     # Varianza
## [1] 3.982143
sd(my_vec)      # Deviazione standard
## [1] 1.995531
length(my_vec)  # Numero di elementi
## [1] 8
```

Puoi anche salvare i risultati in nuovi oggetti per riutilizzarli:

```R
vec_mean <- mean(my_vec)
vec_mean
## [1] 3.625
```

### Creare sequenze regolari

Per creare sequenze di numeri in passi regolari, puoi usare i seguenti comandi:

- **Simbolo `:`** per sequenze semplici:
  ```R
  my_seq <- 1:10
  ## [1]  1  2  3  4  5  6  7  8  9 10
  ```

- **Funzione `seq()`** per maggiore controllo:
  ```R
  my_seq2 <- seq(from = 1, to = 5, by = 0.5)
  ## [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0
  ```

### Ripetere valori

Puoi ripetere valori o sequenze con la funzione `rep()`:

- Ripetere un valore:
  ```R
  my_seq3 <- rep(2, times = 10)
  ## [1] 2 2 2 2 2 2 2 2 2 2
  ```

- Ripetere una sequenza:
  ```R
  my_seq5 <- rep(1:5, times = 3)
  ## [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5
  ```

- Ripetere ogni elemento di una sequenza:
  ```R
  my_seq6 <- rep(1:5, each = 3)
  ## [1] 1 1 1 2 2 2 3 3 3 4 4 4 5 5 5
  ```

### Annidare funzioni

È possibile combinare funzioni per creare comandi più complessi, come nell'esempio:

```R
my_seq7 <- rep(c(3, 1, 10, 7), each = 3)
## [1]  3  3  3  1  1  1 10 10 10  7  7  7
```

Per maggiore leggibilità, puoi separare i passaggi:

```R
in_vec <- c(3, 1, 10, 7)
my_seq7 <- rep(in_vec, each = 3)
## [1]  3  3  3  1  1  1 10 10 10  7  7  7
```

Questa pratica facilita la comprensione del codice e lo rende più chiaro.


## Lavorare con i vettori in R 

In R, i vettori sono uno degli elementi fondamentali per manipolare, riassumere e ordinare i dati. Qui trovi una panoramica su come estrarre, sostituire, ordinare, lavorare con dati mancanti e sfruttare la vettorizzazione dei vettori.

### Estrarre elementi da un vettore

Puoi estrarre uno o più elementi da un vettore usando le parentesi quadre `[ ]`.

1. **Per posizione**: Specifica la posizione degli elementi.  
   ```R
   my_vec <- c(2, 3, 1, 6, 4, 3, 3, 7)
   my_vec[3]  # Terzo elemento
   ## [1] 1
   my_vec[c(1, 5, 6)]  # Elementi 1°, 5° e 6°
   ## [1] 2 4 3
   my_vec[3:8]  # Da 3° a 8°
   ## [1] 1 6 4 3 3 7
   ```

2. **Con condizioni logiche**: Usa espressioni logiche per selezionare elementi.
   ```R
   my_vec[my_vec > 4]  # Elementi > 4
   ## [1] 6 7
   my_vec[my_vec <= 4]  # Elementi ≤ 4
   ## [1] 2 3 1 4 3 3
   my_vec[my_vec != 4]  # Elementi diversi da 4
   ## [1] 2 3 1 6 3 3 7
   ```

3. **Operatori logici**: Combina condizioni con `&` (AND) e `|` (OR).  
   ```R
   my_vec[my_vec > 2 & my_vec < 6]  # Tra 2 e 6
   ## [1] 3 4 3 3
   ```

### Sostituire elementi in un vettore

Puoi modificare i valori di un vettore usando `[ ]` e l'operatore `<-`.

1. **Un singolo elemento**:  
   ```R
   my_vec[4] <- 500  # Cambia il 4° elemento
   ## [1]   2   3   1 500   4   3   3   7
   ```

2. **Più elementi**:  
   ```R
   my_vec[c(6, 7)] <- 100  # Cambia il 6° e 7° elemento
   ## [1]   2   3   1 500   4 100 100   7
   ```

3. **Con condizioni logiche**:  
   ```R
   my_vec[my_vec <= 4] <- 1000  # Cambia valori ≤ 4
   ## [1] 1000 1000 1000  500 1000  100  100    7
   ```

### Ordinare un vettore

1. **Dal più piccolo al più grande**:  
   ```R
   vec_sort <- sort(my_vec)
   ## [1]    7  100  100  500 1000 1000 1000 1000
   ```

2. **Dal più grande al più piccolo**:  
   ```R
   vec_sort2 <- sort(my_vec, decreasing = TRUE)
   ## [1] 1000 1000 1000 1000  500  100  100    7
   ```

3. **Ordinare un vettore in base a un altro**:  
   ```R
   height <- c(180, 155, 160, 167, 181)
   p.names <- c("Joanna", "Charlotte", "Helen", "Karen", "Amy")
   height_ord <- order(height)
   names_ord <- p.names[height_ord]
   ## [1] "Charlotte" "Helen"     "Karen"     "Joanna"    "Amy"
   ```

### Operazioni vettoriali (vettorizzazione)

Le funzioni in R sono *vettorizzate*, cioè operano automaticamente su tutti gli elementi di un vettore senza bisogno di un ciclo.

1. **Operazioni aritmetiche**:  
   ```R
   my_vec2 <- c(3, 5, 7, 1, 9, 20)
   my_vec2 * 5  # Moltiplica ogni elemento per 5
   ## [1]  15  25  35   5  45 100
   ```

2. **Operazioni tra vettori**:  
   ```R
   my_vec3 <- c(17, 15, 13, 19, 11, 0)
   my_vec2 + my_vec3  # Somma due vettori
   ## [1] 20 20 20 20 20 20
   ```

3. **Riciclo (recycling)**: Attenzione quando i vettori hanno lunghezze diverse.
   ```R
   my_vec4 <- c(1, 2)
   my_vec2 + my_vec4  # R ricicla gli elementi del vettore più corto
   ## [1]  4  7  8  3 10 22
   ```

### Gestire dati mancanti (NA)

R rappresenta i dati mancanti con `NA`. La gestione dei dati mancanti dipende dalla funzione utilizzata.

1. **Calcolo con dati mancanti**:  
   ```R
   temp <- c(7.2, NA, 7.1, 6.9, 6.5, 5.8, 5.8, 5.5, NA, 5.5)
   mean(temp)  # Restituisce NA
   ## [1] NA

   mean(temp, na.rm = TRUE)  # Ignora i valori mancanti
   ## [1] 6.2875
   ```

**Nota**: `na.rm = TRUE` è un argomento comune per ignorare i `NA`, ma non tutte le funzioni lo supportano. Consulta la documentazione della funzione per verificare come gestisce i dati mancanti.

In conclusione, manipolare vettori è un’abilità essenziale in R. Dalla selezione e modifica degli elementi all’ordinamento e gestione di dati mancanti, queste tecniche sono alla base dell’analisi dei dati in R.

## I dati in R 

In R, i dati possono essere rappresentati in diversi tipi e strutture. Comprendere come gestirli è fondamentale per manipolare, analizzare e riassumere i dataset più complessi.

### Tipi di dati in R

R supporta diversi tipi di dati:

1. **Numeric**: Numeri decimali (es. `2.5`).
2. **Integer**: Numeri interi (es. `3`).
3. **Logical**: Valori booleani (`TRUE` o `FALSE`) e `NA` per dati mancanti.
4. **Character**: Stringhe di testo (es. `"hello"`).
5. **Factor**: Variabili categoriche (es. livelli come `"low"`, `"medium"`, `"high"`).

Puoi verificare il tipo di un oggetto con `class()` e controllare se appartiene a un tipo specifico con funzioni come `is.numeric()`. È anche possibile convertire un tipo in un altro con funzioni come `as.character()`.

### Strutture di dati in R

1. **Vettori**: Contengono dati dello stesso tipo (es. numeri, stringhe o logici).  
   ```R
   my_vec <- c(1, 2, 3)
   ```

2. **Matrici e array**: Strutture bidimensionali (matrici) o multidimensionali (array) con dati dello stesso tipo.  
   Creare una matrice:
   ```R
   my_mat <- matrix(1:12, nrow = 3, byrow = TRUE)
   ##      [,1] [,2] [,3] [,4]
   ## [1,]    1    2    3    4
   ## [2,]    5    6    7    8
   ## [3,]    9   10   11   12
   ```
   
   Operazioni utili:
   
   - **Trasposizione**: `t(my_mat)`
   - **Diagonale**: `diag(my_mat)`
   - **Moltiplicazione matriciale**: `mat1 %*% mat2`

3. **Liste**: Possono contenere elementi di tipi diversi, inclusi vettori, matrici o altre liste.  

   ```R
   my_list <- list(numbers = c(1, 2), text = "hello", mat = matrix(1:4, nrow = 2))
   my_list$numbers  # Accedi agli elementi con il nome
   ```

4. **Data frame**: Strutture bidimensionali che possono contenere colonne di tipi diversi. Ideale per dataset strutturati.  
   Creare un data frame:
   
   ```R
   height <- c(180, 155, 160)
   weight <- c(65, 50, 52)
   names <- c("Joanna", "Charlotte", "Helen")

   dataf <- data.frame(height = height, weight = weight, names = names)
   str(dataf)  # Mostra la struttura del data frame
   ## 'data.frame':    3 obs. of  3 variables:
   ##  $ height: num  180 155 160
   ##  $ weight: num  65 50 52
   ##  $ names : chr  "Joanna" "Charlotte" "Helen"
   ```

   Per convertire le stringhe in fattori durante la creazione:
   ```R
   dataf <- data.frame(height = height, weight = weight, names = names, stringsAsFactors = TRUE)
   ```

### Operazioni utili sui data frame

- **Verificare dimensioni**: `dim(dataf)`
- **Visualizzare struttura**: `str(dataf)`
- **Accedere a colonne**: `dataf$height`


### Considerazioni

- Le matrici e gli array sono utili per dati numerici omogenei.  
- I data frame sono più flessibili, permettendo dati di tipi diversi.  
- Le liste sono ideali per strutture dati irregolari o gerarchiche.  

## Importare dati in R con `rio::import()`

In R, è possibile creare un *data frame* importando dati da file esterni, che rappresenta il metodo più comune per iniziare un'analisi. Per fare questo, è importante che i dati siano ben formattati e salvati in un formato riconosciuto da R. 

La funzione `rio::import()` del pacchetto **`rio`** è uno strumento generale e molto pratico per importare dati da una vasta gamma di formati di file senza dover ricordare funzioni specifiche per ciascun tipo di file.

1. **Supporto per diversi formati**: Riconosce automaticamente il tipo di file (es. `.csv`, `.xlsx`, `.sav`, `.json`) in base all'estensione.
2. **Facilità d'uso**: Richiede solo il percorso del file come argomento principale.

In sintesi, **`rio::import()`** è una funzione versatile e potente che semplifica l'importazione dei dati in R, rendendola una scelta eccellente per lavorare con dataset di vario tipo.


## Informazioni sull'Ambiente di Sviluppo {.unnumbered}

```{r}
sessionInfo()
```

## Bibliografia {.unnumbered}
