Fantastico â€” il capitolo Ã¨ giÃ  molto solido. Qui sotto trovi:

1. **Correzioni puntuali** (cosa cambiare, dove, e perchÃ©).
2. **Versione rivista** pronta da incollare (testo + codice) delle parti che hai postato.

---

# 1) Cosa cambiare (punti rapidi e motivati)

**Introduzione**

* âœ… Va bene. Solo una micro-limatura stilistica per rendere esplicito il perchÃ© usiamo Stan ora: *per imparare il workflow MCMC anche quando non esistono soluzioni chiuse*.

**Sezione â€œDal modello teorico al modello computazionaleâ€**

* ğŸ” Frase da correggere: â€œAvendo tutti i giorni hanno la stessa durataâ€ â†’ **â€œPoichÃ© tutte le finestre hanno la stessa durataâ€**.
* ğŸ“ Precisione su esposizione: mantieni la forma generale con $t_i$ e poi specializza a $t_i=1$. Bene comâ€™Ã¨.
* ğŸ§  Nota interpretativa: chiarisci che **$\lambda$ Ã¨ il numero medio di eventi per finestra**; il **tempo medio tra eventi** Ã¨ $1/\lambda$ *solo* nel modello dei **tempi di attesa** (esponenziale). Lâ€™hai giÃ  impostato bene; ho reso il passaggio ancora piÃ¹ esplicito.

**Prior Gamma**

* âœ… Parametrizzazione *shapeâ€“rate* corretta. Aggiungo solo la formula della deviazione standard per completezza: $\text{sd}(\lambda)=\sqrt{\alpha}/\beta$.

**Stan (modello semplice i.i.d.)**

* ğŸ§± Blocchi corretti.
* ğŸ§ª *Generated quantities*: se vuoi fare **LOO** in futuro, sostituisci lo scalare `log_lik` con un **vettore per-osservazione**:

  ```stan
  generated quantities {
    array[N] real log_lik;
    for (i in 1:N) log_lik[i] = poisson_lpmf(y[i] | lambda);
  }
  ```

  (Ãˆ piÃ¹ utile di una somma unica.)
* ğŸ§® Il calcolo di `alpha_post`/`beta_post` nei `generated quantities` Ã¨ facoltativo ma didatticamente ottimo.

**R: preparazione ed esecuzione**

* ğŸ§­ Se usi `here::here(...)`, **carica `here`** o, per evitare dipendenze, usa direttamente `write_stan_file(stan_code)` (ti propongo sotto questa via, piÃ¹ portabile).
* ğŸ“¦ Usa sempre `posterior::summarise_draws` (forma â€œUKâ€) per coerenza, altrimenti mescoli `summarize`/`summarise`.
* ğŸ§µ Estrazione campioni: `lambda_samples <- fit$draws("lambda", format = "df")$lambda` Ã¨ piÃ¹ pulito di `as.vector(...)`.
* ğŸ§° Nomi grafici: correggi â€œTraceplot di controllo su **OR**â€ â†’ **â€œTraceplot di lambdaâ€**.

**Sparatorie mortali (parte applicativa)**

* ğŸ“… Coerenza temporale: **escludi il 2025** perchÃ© incompleto, non il 2024 (giÃ  corretto).
* ğŸ”¢ Non fissare numeri nel testo (es. â€œmedia 1042, CI \[1022, 1062]â€) perchÃ© dipendono dal run e dallâ€™aggiornamento del dataset. Meglio: *â€œriporta i valori del chunk seguenteâ€*.
* ğŸ§­ Nota modellistica: segnala che lâ€™assunzione i.i.d. Ã¨ **semplificativa** (trend crescente). Aggiungo un box â€œEstensioniâ€ (trend/effetti casuali/offset).

---

# 2) Versione rivista (incolla al posto della tua)

## Introduzione {.unnumbered .unlisted}

\::: {.lead}
In questo capitolo affrontiamo un primo esempio di modellazione con *Stan*, il linguaggio che useremo per costruire modelli statistici e fare inferenza bayesiana. Riprendiamo un caso giÃ  risolto con metodi analitici e con il metodo su griglia â€” il modello *Gammaâ€“Poisson* â€” e lo affrontiamo ora con il campionamento MCMC. In questo modo possiamo confrontare i risultati e, soprattutto, imparare un workflow che useremo anche quando **non esistono** soluzioni chiuse.
\:::

## Dal modello teorico al modello computazionale

Supponiamo di osservare, in otto finestre temporali di pari durata, quante volte si verifica un certo evento (per esempio: il numero di compulsioni in otto momenti della giornata, oppure le chiamate ricevute in otto turni orari). I dati sono:

```{r}
y <- c(2, 1, 3, 2, 2, 1, 1, 1)
```

Abbiamo quindi $N=8$ osservazioni. Vogliamo stimare $\lambda$, il **tasso medio di occorrenza per unitÃ  di tempo** (qui: per finestra di osservazione). Per fenomeni di conteggio assumiamo una **distribuzione di Poisson**. In presenza di esposizioni (durate) potenzialmente diverse $t_i>0$, il modello naturale Ã¨

$$
y_i \sim \text{Poisson}(\mu_i), 
\qquad \mu_i = \lambda\, t_i,
$$

ossia

$$
P(y_i \mid \lambda) \;=\; \frac{(\lambda\, t_i)^{y_i} e^{-\lambda\, t_i}}{y_i!},
\quad y_i \in \mathbb{N},\ \lambda>0.
$$

PoichÃ© qui tutte le finestre hanno la **stessa durata** ($t_i=1$), la formula si semplifica in

$$
P(y_i \mid \lambda) \;=\; \frac{\lambda^{y_i} e^{-\lambda}}{y_i!},
\qquad \mathbb{E}[y_i]=\lambda,\quad \mathrm{Var}(y_i)=\lambda.
$$

In altre parole, **$\lambda$ coincide con il numero medio di eventi per finestra** (ad es. per turno/ora o per giorno). Da non confondere con i **tempi di attesa** tra eventi: lÃ¬ la media Ã¨ $1/\lambda$, ma riguarda il modello esponenziale, non i conteggi.

Per lâ€™analisi bayesiana specifichiamo una **prior coniugata Gamma** in parametrizzazione *shapeâ€“rate* $(\alpha,\beta)$, con densitÃ 

$$
p(\lambda) \;=\; \frac{\beta^{\alpha}}{\Gamma(\alpha)}\, \lambda^{\alpha - 1} e^{-\beta \lambda},
\quad \lambda>0,
$$

per cui

$$
\mathbb{E}[\lambda] = \frac{\alpha}{\beta}, 
\qquad \mathrm{Var}(\lambda) = \frac{\alpha}{\beta^{2}},
\qquad \mathrm{sd}(\lambda)=\frac{\sqrt{\alpha}}{\beta}.
$$

Nel nostro esempio poniamo $\alpha=9$ e $\beta=2$: la prior ha media $\alpha/\beta=4{,}5$ (circa 4â€“5 eventi per finestra) e deviazione standard $\sqrt{\alpha}/\beta \approx 1{,}5$, che esprime moderata informazione con adeguata incertezza.

## Scrivere il modello in Stan

Un modello Stan Ã¨ diviso in blocchi: *data* (dati), *parameters* (incognite), *model* (priori + verosimiglianza). Aggiungiamo anche *generated quantities* per quantitÃ  derivate utili al confronto con la soluzione analitica (e, volendo, per LOO).

```stan
data {
  int<lower=0> N;                // numero di osservazioni
  array[N] int<lower=0> y;       // dati osservati
  real<lower=0> alpha_prior;     // shape prior
  real<lower=0> beta_prior;      // rate prior
}
parameters {
  real<lower=0> lambda;          // parametro di interesse
}
model {
  lambda ~ gamma(alpha_prior, beta_prior);   // prior
  y ~ poisson(lambda);                       // verosimiglianza (somme su i automaticamente)
}
generated quantities {
  // Parametri posteriori teorici (Gammaâ€“Poisson) â€” opzionale, a scopo didattico
  real alpha_post = alpha_prior + sum(y);
  real beta_post  = beta_prior + N;

  // Log-likelihood per osservazione (utile per LOO-CV)
  array[N] real log_lik;
  for (i in 1:N) log_lik[i] = poisson_lpmf(y[i] | lambda);
}
```

## Preparare i dati ed eseguire il modello in R

Per evitare dipendenze da percorsi locali, creiamo e compiliamo il modello direttamente dalla stringa:

```{r}
library(cmdstanr)
library(posterior)
library(ggplot2)

stan_code <- "
data {
  int<lower=0> N;
  array[N] int<lower=0> y;
  real<lower=0> alpha_prior;
  real<lower=0> beta_prior;
}
parameters {
  real<lower=0> lambda;
}
model {
  lambda ~ gamma(alpha_prior, beta_prior);
  y ~ poisson(lambda);
}
generated quantities {
  real alpha_post = alpha_prior + sum(y);
  real beta_post  = beta_prior + N;
  array[N] real log_lik;
  for (i in 1:N) log_lik[i] = poisson_lpmf(y[i] | lambda);
}
"

mod <- cmdstan_model(write_stan_file(stan_code))

N <- length(y)
alpha_prior <- 9
beta_prior  <- 2

stan_data <- list(N = N, y = y, alpha_prior = alpha_prior, beta_prior = beta_prior)

fit <- mod$sample(
  data = stan_data,
  seed = 123,
  chains = 4,
  parallel_chains = 4,
  iter_sampling = 3000,
  iter_warmup = 2000,
  refresh = 0
)
```

## Analizzare i risultati

Estraiamo i campioni di $\lambda$ e i parametri posteriori teorici:

```{r}
lambda_samples <- fit$draws("lambda", format = "df")$lambda

alpha_post <- alpha_prior + sum(y)
beta_post  <- beta_prior + N
```

Istogramma dei campioni MCMC + curva Gamma teorica:

```{r}
ggplot(data.frame(lambda = lambda_samples), aes(x = lambda)) +
  geom_histogram(aes(y = after_stat(density)), bins = 50, fill = "skyblue", alpha = 0.7) +
  stat_function(
    fun = function(x) dgamma(x, shape = alpha_post, rate = beta_post),
    color = "red", linewidth = 1.2
  ) +
  labs(title = "Distribuzione a posteriori di Î»", x = "Î»", y = "DensitÃ ")
```

Intervallo di credibilitÃ  (94% centrale, ad es.):

```{r}
quantile(lambda_samples, probs = c(0.03, 0.97))
```

Diagnostica essenziale:

```{r}
posterior::summarise_draws(fit$draws("lambda"), rhat, ess_bulk, ess_tail)

bayesplot::mcmc_trace(fit$draws("lambda")) +
  ggtitle("Traceplot di lambda")
```

---

## Sparatorie mortali

### Domanda della ricerca

Come spiegato nella documentazione del dataset, i dati del *Washington Post* registrano ogni sparatoria mortale da parte della polizia negli USA dal **1Â° gennaio 2015**.

**Obiettivo.** Stimare, per il periodo 2015â€“**ultimo anno completo disponibile**, il **tasso medio annuo** e lâ€™**incertezza** associata. PoichÃ© il **2025** Ã¨ incompleto, lo escludiamo.

### Importazione e pre-processing

```{r}
library(tidyverse)
library(lubridate)

url <- "https://raw.githubusercontent.com/washingtonpost/data-police-shootings/master/v2/fatal-police-shootings-data.csv"
fps_dat <- read_csv(url, show_col_types = FALSE) %>%
  mutate(date = ymd(date), year = year(date))

fps <- fps_dat %>% filter(year != 2025)

year_counts <- fps %>%
  count(year, name = "events") %>%
  arrange(year)

print(year_counts)
```

### Modello di Poisson (pooling completo)

Assumiamo $y_t \sim \text{Poisson}(\lambda)$ con $\lambda$ costante sul periodo:

```{r}
y_vec <- year_counts$events

mu    <- 600
sigma <- 200
alpha_prior <- (mu / sigma)^2
beta_prior  <- mu / sigma^2

stan_code2 <- "
data {
  int<lower=1> N;
  array[N] int<lower=0> y;
  real<lower=0> alpha_prior;
  real<lower=0> beta_prior;
}
parameters {
  real<lower=0> lambda;
}
model {
  lambda ~ gamma(alpha_prior, beta_prior);
  y ~ poisson(lambda);
}
generated quantities {
  array[N] real log_lik;
  for (t in 1:N) log_lik[t] = poisson_lpmf(y[t] | lambda);
}
"
mod2 <- cmdstan_model(write_stan_file(stan_code2))

stan_data2 <- list(
  N = length(y_vec),
  y = as.integer(y_vec),
  alpha_prior = alpha_prior,
  beta_prior  = beta_prior
)

fit2 <- mod2$sample(
  data = stan_data2,
  iter_warmup = 1000,
  iter_sampling = 4000,
  chains = 4,
  seed = 123,
  refresh = 0
)

fit2$summary("lambda")

posterior::summarise_draws(
  fit2$draws("lambda"),
  mean, sd, ~quantile(.x, c(0.025, 0.5, 0.975))
)

bayesplot::mcmc_areas(fit2$draws("lambda"), prob = 0.95) +
  ggtitle("Posterior di Î» (ICr 95%)")
```

> **Nota modellistica.** Qui abbiamo trattato i conteggi come i.i.d., ma la serie mostra un **trend crescente**. Questo modello serve come baseline e per mostrare la coerenza con la soluzione **Gammaâ€“Poisson** coniugata.

### Derivazione analitica (check coniugato)

```{r}
n        <- length(y_vec)
sum_y    <- sum(y_vec)

alpha_post <- alpha_prior + sum_y
beta_post  <- beta_prior  + n

post_mean <- alpha_post / beta_post
ci95      <- qgamma(c(0.025, 0.975), shape = alpha_post, rate = beta_post)

cat("Posterior mean Î»:", round(post_mean, 2), "\n")
cat("95% CrI: [", round(ci95[1], 2), ", ", round(ci95[2], 2), "]\n")
```

Le stime **analitiche** e **MCMC** coincidono (entro errore Monte Carlo).

\::: {.callout-note}

### Estensioni utili

* **Trend**: $\log \lambda_t = \alpha + \beta \cdot (t - \bar t)$ con `poisson_log`.
* **Pooling parziale** tra anni: $\log \lambda_t \sim \mathcal N(\mu_\lambda, \sigma_\lambda)$.
* **Offset**: includi denominatori (es. popolazione) con $\log \mu_t = \log E_t + \eta_t$.
  \:::

## Riflessioni conclusive

Abbiamo tradotto un modello semplice in Stan, eseguito MCMC e confrontato le stime con la soluzione analitica. Questo conferma sia la **correttezza della specifica** sia il **workflow** di analisi (modellazione â†’ campionamento â†’ diagnostica â†’ confronto). Lo stesso schema guiderÃ  i capitoli successivi, dove la coniugatezza non ci assisterÃ  e Stan diventerÃ  lo strumento principale per lâ€™inferenza.

---

## Mini-checklist â€œdiff da fareâ€

* [ ] Sostituisci â€œAvendo tutti i giorni hannoâ€¦â€ con â€œ**PoichÃ© tutte le finestre hannoâ€¦**â€.
* [ ] In Stan, in `generated quantities` **usa il vettore** `log_lik[N]` (invece dello scalare) se vuoi LOO.
* [ ] In R, estrai i campioni con `fit$draws("lambda", format = "df")$lambda` e usa **`summarise_draws`** ovunque (no `summarize_draws`).
* [ ] Correggi il titolo â€œTraceplot di controllo su **OR**â€ â†’ **â€œTraceplot di lambdaâ€**.
* [ ] Nel testo **non fissare numeri** (media/ICr) per il caso reale: rimanda ai valori stampati dai chunk.
* [ ] Mantieni lâ€™esclusione del **2025** (anno corrente incompleto).

Se vuoi, posso fornirti **snippet aggiuntivi** per: (i) modello con **offset** per popolazione, (ii) **trend log-lineare** con `poisson_log`, (iii) pooling parziale su anno (modello gerarchico).
